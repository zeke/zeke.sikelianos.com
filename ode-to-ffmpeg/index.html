<!DOCTYPE html>
<html>

<head>
  
    <title>Ode to FFmpeg | Zeke Sikelianos</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- OpenGraph Meta Tags -->
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Zeke Sikelianos">
  
    <meta property="og:title" content="Ode to FFmpeg">
  
  
    <meta property="og:description" content="A tribute to the Swiss Army knife of multimedia processing">
    <meta name="description" content="A tribute to the Swiss Army knife of multimedia processing">
  
  <meta property="og:url" content="https://zeke.sikelianos.com/ode-to-ffmpeg">
  

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@zeke">
  <meta name="twitter:creator" content="@zeke">
  
    <meta name="twitter:title" content="Ode to FFmpeg">
  
  
    <meta name="twitter:description" content="A tribute to the Swiss Army knife of multimedia processing">
  
  

  <link rel="stylesheet" href="../index.css">
  <script src="https://unpkg.com/browser-date-formatter@3.0.2/dist.js"></script>
  <script src="../index.js"></script>
</head>

<body>

  

  <div class="site-nav">
    <a href="/">Gallery</a>
    <a href="/projects">Projects</a>
    <a href="/talks">Talks</a>
    <a href="/posts">Posts</a>
    <a href="/portfolio">Portfolio</a>
    <a href="/cv">CV</a>
    <a href="/contact">Contact</a>
  </div>

  <article>
    <div class="page__content">
      <header>
        <h1 class="page__title">Ode to FFmpeg</h1>
        
          <h2 class="page__description">A tribute to the Swiss Army knife of multimedia processing</h2>
        
        
          <div class="page__publish-date">
            
              <time title="Wed Aug 27 2025 00:00:00 GMT+0000 (Coordinated Universal Time)" data-date="Wed Aug 27 2025 00:00:00 GMT+0000 (Coordinated Universal Time)" data-format="%B %Y">Wed Aug 27 2025 00:00:00 GMT+0000 (Coordinated Universal Time)</time>
            
          </div>
        
      </header>

      <p>This is a love letter to FFmpeg, an open-source tool for processing audio, images, and video. This is also a love letter to large language models like ChatGPT and Claude, for they make it possible for mere mortals to actually use FFmpeg effectively.</p>
<h2 id="ffwhat"><a href="#ffwhat">FFwhat?</a></h2>
<p>FFmpeg is a free and open-source software tool for processing audio, images, and video. It's been around since 2000, and it is truly ubiquitous.</p>
<p>FFmpeg powers virtually every major streaming platform, social media site, and video application you use daily. Netflix, YouTube, Instagram, TikTok, Twitch... all of these services rely on FFmpeg libraries. Your phone's camera app uses it. NASA's Perseverance rover uses it to process and compress video on Mars.</p>
<p>It's literally everywhere.</p>
<h2 id="it-can-do-anything"><a href="#it-can-do-anything">It can do anything!</a></h2>
<p>FFMpeg is not just used by streaming media giants. It's open-source, so anyone can download and use it for free.</p>
<p>FFmpeg can handle virtually any multimedia processing task you can imagine: It converts between hundreds of audio and video formats. It extracts frames from videos or combines sequences of images into videos. It can add or remove audio tracks, synchronize audio with video, and mix multiple audio sources together. It can apply visual effects like blurs, color corrections, or transitions between scenes. It can rotate videos, add watermarks, and create slow-motion and time-lapse effects.</p>
<p>For programmers working with multimedia, FFmpeg is an essential tool.</p>
<h2 id="but-theres-a-catch"><a href="#but-theres-a-catch">But there's a catch...</a></h2>
<p>This all sounds great, but there's a catch: FFmpeg is some of the <em>most difficult software on earth</em> to actually use.</p>
<p>It's a command-line tool, which means you type complex commands to use it. These commands are not intuitive, and they are not easy to write. Consider this real FFmpeg command that extracts every 10th frame from a video, applies a sepia filter, adds a watermark, and outputs a gif with custom dithering:</p>
<pre><code class="hljs language-bash">ffmpeg -i input.mp4 \
    -vf <span class="hljs-string">"select='not(mod(n,10))',setpts=N/FRAME_RATE/TB,colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131,scale=640:-1:flags=lanczos,overlay=(main_w-overlay_w-10):10"</span> \
    -r 2 \
    -f gif \
    -lavfi <span class="hljs-string">"palettegen=stats_mode=single[palette];[0:v][palette]paletteuse=dither=bayer"</span> \
    output.gif</code></pre>
<p>If you've ever tried to write a command like this, you know it's a fool's errand. So hard to get it right! I used to look these up on Stack Overflow, find a command that some kind soul had shared, and then try to modify it to my needs, usually with limited success.</p>
<p>So we have this great tool, but it's locked behind a wall of complexity that makes it inaccessible to most people.</p>
<h2 id="enter-llms"><a href="#enter-llms">Enter LLMs</a></h2>
<p>Large language models like ChatGPT and Claude are changing all of this. They can translate natural language descriptions into working code, including FFmpeg commands. Instead of memorizing that dense syntax above, you can now describe what you want in plain language:</p>
<blockquote>
<p>"Take my video, grab every 10th frame, make it look sepia-toned, add my logo in the corner, and turn it into a smooth gif"</p>
</blockquote>
<p>An LLM will translate that description into the proper FFmpeg command, complete with the right flags, filters, and parameters. No more hunting through man pages, no more trial and error with codec options, no more wondering about the subtle differences between <code>-vf</code> and <code>-filter:v</code>.</p>
<p>This represents more than convenience—it's a fundamental shift in accessibility. FFmpeg's capabilities, previously gated behind years of learning arcane syntax, can now be accessed by anyone who can describe their intent clearly using natural language. Not just English, either. You can write your LLM commands in Japanese, Spanish, or Russian. The tool that once required deep technical knowledge to use effectively can now respond to conversational requests.</p>
<h2 id="try-it-yourself"><a href="#try-it-yourself">Try it yourself</a></h2>
<h3 id="using-chatgpt-and-claude"><a href="#using-chatgpt-and-claude">Using ChatGPT and Claude</a></h3>
<p>Both ChatGPT and Claude excel at generating FFmpeg commands from natural language descriptions. You can simply explain what you want to do with your media files, and they'll provide the exact command syntax. Ask for explanations of complex commands, help debugging failed operations, or assistance optimizing encoding settings for specific use cases.</p>
<p>For example, you might ask: "How do I convert an MP4 to WebM with good compression for web use?" and receive not just the command, but explanations of the encoding options and quality trade-offs involved.</p>
<p>The key is to be specific about your input format, desired output, and any quality or size constraints. The more detail you provide, the better the generated command will be.</p>
<h3 id="smart-ffmpeg-model"><a href="#smart-ffmpeg-model">Smart FFmpeg Model</a></h3>
<p>For even more direct processing, there's <a href="https://replicate.com/fofr/smart-ffmpeg">Smart FFmpeg</a>, an AI model on Replicate that takes this concept further. Instead of just generating commands, you can upload your actual media files and provide natural language instructions for how to modify them. The model processes your files directly and returns the results—no command line required.</p>
<p>You can use Smart FFmpeg through a web browser interface or integrate it into applications using Replicate's HTTP API. This removes the last barrier between intent and execution: you describe what you want, upload your files, and get the processed results back without ever touching the command line.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> Replicate <span class="hljs-keyword">from</span> <span class="hljs-string">"replicate"</span>

<span class="hljs-keyword">const</span> replicate = <span class="hljs-keyword">new</span> Replicate()
<span class="hljs-keyword">const</span> model = <span class="hljs-string">"fofr/smart-ffmpeg"</span>
<span class="hljs-keyword">const</span> input = {
  <span class="hljs-attr">files</span>: [
    <span class="hljs-string">"https://replicate.delivery/pbxt/NYZZGpR5tZINdJQLLp8pUziwdNeouXe1HQt8VkGWEzWNRVqw/vpz04dbqv9rme0crnxg9r1x9j8.mp4"</span>,
    <span class="hljs-string">"https://replicate.delivery/pbxt/NYZZH2dFu1qBUt2PpTKd2ZadLMGT9Z0E9vLzg7hidlLG9NWX/hc7hehnhw5rm80crnxf8j703cm.mp4"</span>],
  <span class="hljs-attr">prompt</span>: <span class="hljs-string">"Concatenate these two videos, and add a circleopen effect to the transition"</span>,
  <span class="hljs-attr">max_attempts</span>: <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> output = <span class="hljs-keyword">await</span> replicate.run(model, { input })
<span class="hljs-built_in">console</span>.log(output)</code></pre>
    </div>
  </article>

  <footer>
    <div class="site-nav">
      <a href="/">Gallery</a>
      <a href="/projects">Projects</a>
      <a href="/talks">Talks</a>
      <a href="/posts">Posts</a>
      <a href="/portfolio">Portfolio</a>
      <a href="/cv">CV</a>
      <a href="/contact">Contact</a>
    </div>
  </footer>
</body>
</html>